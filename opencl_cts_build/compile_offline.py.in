#!/usr/bin/env python3
# Copyright (C) Codeplay Software Limited. All Rights Reserved.
"""
Implements the offline compiler interface as specified in the OpenCL-CTS
repo (see OpenCL-CTS/test_common/harness/cl_offline_compiler-interface.txt)
"""

import argparse
import errno
import os
import re
import subprocess
import sys
import shlex
import time

COMPILATION_WRAPPER = r'@CompilationWrapper@'

TMP_OUTPUT = ''

def parse_device_info(device_info_path):
    """Parses the device info file provided by the CTS test executable."""
    device_info_dict = {}
    with open(device_info_path) as device_info_file:
        for line in device_info_file:
            if line[0] == '#':
                continue
            device_info_data = line.split('=', 1)
            device_info_dict[
                device_info_data[0].strip()] = device_info_data[1].strip()
    return device_info_dict


def triple(device_info):
    """Returns the target triple based on the device address bits."""
    return {
        '32': 'spir-unknown-unknown',
        '64': 'spir64-unknown-unknown'
    }[device_info['CL_DEVICE_ADDRESS_BITS']]


def cl_std(device_info):
    """Returns the OpenCL C standard based on the device version."""
    cl_version_pattern = re.compile(r'OpenCL ([0-9]\.[0-9])')
    cl_version_match = cl_version_pattern.search(
        device_info['CL_DEVICE_VERSION'])
    if not cl_version_match:
        sys.exit('error: valid OpenCL version not found in device info file')
    return 'CL%s' % cl_version_match.group(1)


def call(command, input=None, output=None):
    """Calls the given command, using the compilation wrapper if specified."""
    if COMPILATION_WRAPPER:
        wrapper_command = [COMPILATION_WRAPPER]
        if input:
            wrapper_command += ['-i', input]
        if output:
            wrapper_command += ['-o', output]
        wrapper_command += [' '.join([shlex.quote(arg) for arg in command])]
        subprocess.check_call(wrapper_command)
    else:
        subprocess.check_call(command)


def spirv(args, device_info):
    """Compile a SPIR-V module from the given OpenCL C source."""
    clang = os.environ.get('CLANG_EXECUTABLE', r'@CLANG_EXECUTABLE@')
    if clang == '':
        sys.exit('error: environment variable not set and no '
                 'default value found: CLANG_EXECUTABLE')
    image_support = int(device_info['CL_DEVICE_IMAGE_SUPPORT'].strip('\n'))
    image_macro_def = "" if image_support else "-U__IMAGE_SUPPORT__"
    bc_file = args.source + '.bc'
    clang_command = [
        clang, '-cc1', '-emit-llvm-bc', '-triple',
        triple(device_info), '-O0', '-finclude-default-header',
        '-cl-std=%s' % cl_std(device_info)
    ] + args.user_build_options + [
        image_macro_def, args.source, '-o', bc_file
    ]
    llvm_spirv = os.environ.get('LLVM_SPIRV_EXECUTABLE',
                                r'@LLVM_SPIRV_EXECUTABLE@')
    if llvm_spirv == '':
        sys.exit('error: environment variable not set and no '
                 'default value found: LLVM_SPIRV_EXECUTABLE')
    spirv_command = [llvm_spirv, bc_file, '-o', args.output]
    call(clang_command, input=args.source)
    call(spirv_command, output=args.output)


def binary(args, device_info):
    """Compile a program binary from the given OpenCL C source."""
    clc = os.environ.get('CLC_EXECUTABLE', r'@CA_CL_CTS_CLC_EXECUTABLE@')
    if clc == '':
        sys.exit('error: environment variable not set and no '
                 'default value found: CLC_EXECUTABLE')
    device_name = device_info['CL_DEVICE_NAME'].strip().replace('"', '')
    clc_command = [
        clc, '-cl-std=%s' % cl_std(device_info), '--device', device_name
    ] + args.user_build_options + ['--output', args.output, args.source]
    call(clc_command, input=args.source, output=args.output)


def main():
    """Main entry point to the script, handles argument parsing."""
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--mode',
        default='spir-v',
        choices=['spir-v', 'binary'],
        help=('offline compiler mode, choose from: spir-v, binary'))
    parser.add_argument('--source', help='OpenCL C source file.')
    parser.add_argument('--output', help='File to output SPIR-V binary into.')
    parser.add_argument('user_build_options',
                        type=str,
                        nargs='*',
                        help='Any additional user options.')
    parser.add_argument('--cl-device-info',
                        help='Path to cl_device_info file.')
    args = parser.parse_args()
    # Some CTS tests share the same source code. When this happens the tests
    # will read and write into the same file on disk during offline compilation.
    # This can result in file system races if tests are run in parallel. Test A
    # can write a compiled kernel into a file whilst test B reads from it. To
    # avoid this scenario we rename the output file appending `.tmp` and rename
    # it only when compilation is complete and the full output is flushed to
    # disk. We also enforce the contraint that only one process can write into
    # the temp file at a time, any processes that encounter a `.tmp` file which
    # is being written to will wait until it is finished writing then return
    # success.

    # If the temporary file already exists then spin here until it has been
    # deleted by the process creating it which got here first, then exit with
    # success.
    output = args.output
    TMP_OUTPUT = output + '.tmp'
    try:
        # We favor os.open over python's builtin open since it will fail if the
        # file already exists when passed the O_CREATE and O_EXCL flags.
        fd = os.open(TMP_OUTPUT, os.O_CREAT | os.O_EXCL)
        os.close(fd)
    except OSError as err:
        if err.errno == errno.EEXIST:
            # File exists, so spin here until it is deleted.
            while os.path.isfile(TMP_OUTPUT):
                time.sleep(1)
            return
        # Something else has gone wrong.
        raise

    # This process is first to create the file so it can go ahead and write
    # to it.

    # Rename the output file to append `.tmp`.
    args.output = TMP_OUTPUT
    {
        'spir-v': spirv,
        'binary': binary,
    }[args.mode](args, parse_device_info(args.cl_device_info))

    # Rename the result and delete the tmp file.
    os.rename(TMP_OUTPUT, output)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        if os.path.isfile(TMP_OUTPUT):
            os.remove(TMP_OUTPUT)
        sys.exit(130)
