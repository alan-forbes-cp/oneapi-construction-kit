// Copyright (C) Codeplay Software Limited
//
// Licensed under the Apache License, Version 2.0 (the "License") with LLVM
// Exceptions; you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://github.com/codeplaysoftware/oneapi-construction-kit/blob/main/LICENSE.txt
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
//
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include <BenchCL/environment.h>
#include <BenchCL/error.h>
#include <CL/cl.h>
#include <benchmark/benchmark.h>

#include <chrono>
#include <string>
#include <vector>

struct CreateData {
  cl_platform_id platform;
  cl_device_id device;
  cl_context context;
  cl_program program;

  CreateData(cl_platform_id plat, cl_device_id dev, cl_context con,
             cl_program prog)
      : platform(plat), device(dev), context(con), program(prog) {}

  ~CreateData() {
    ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseProgram(program));
    ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseContext(context));
  }
};

static CreateData create_data_from_source(const std::string &source) {
  cl_platform_id platform;
  cl_device_id device;
  cl_context context;
  cl_program program;

  platform = benchcl::env::get()->platform;
  device = benchcl::env::get()->device;

  cl_int status = CL_SUCCESS;
  context = clCreateContext(nullptr, 1, &device, nullptr, nullptr, &status);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, status);

  const char *str = source.c_str();

  program = clCreateProgramWithSource(context, 1, &str, nullptr, &status);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, status);

  ASSERT_EQ_ERRCODE(CL_SUCCESS, clBuildProgram(program, 0, nullptr, nullptr,
                                               nullptr, nullptr));

  return CreateData{platform, device, context, program};
}

static CreateData create_data_from_binary(const std::string &binary_32,
                                          const std::string &binary_64) {
  cl_platform_id platform;
  cl_device_id device;
  cl_context context;
  cl_program program;

  platform = benchcl::env::get()->platform;
  device = benchcl::env::get()->device;

  cl_int addr_bits;
  ASSERT_EQ_ERRCODE(CL_SUCCESS,
                    clGetDeviceInfo(device, CL_DEVICE_ADDRESS_BITS,
                                    sizeof(addr_bits), &addr_bits, nullptr));

  std::string binary;

  if (addr_bits == 32) {
    binary = binary_32;
  } else if (addr_bits == 64) {
    binary = binary_64;
  } else {
    assert(false);
  }

  cl_int status = CL_SUCCESS;
  context = clCreateContext(nullptr, 1, &device, nullptr, nullptr, &status);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, status);

  const unsigned char *str[]{(const unsigned char *)binary.c_str()};

  const size_t len = binary.length();

  program = clCreateProgramWithBinary(context, 1, &device, &len, str, nullptr,
                                      &status);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, status);

  ASSERT_EQ_ERRCODE(CL_SUCCESS,
                    clBuildProgram(program, 0, nullptr, "-x spir -spir-std=1.2",
                                   nullptr, nullptr));

  return CreateData{platform, device, context, program};
}

static void KernelCreateFirstKernelInSource(benchmark::State &state) {
  std::string source;

  for (unsigned i = 0; i < state.range(0); i++) {
    source += "kernel void func" + std::to_string(i) + "() {}\n";
  }

  const CreateData cd = create_data_from_source(source);

  const std::string name = "func" + std::to_string(0);

  for (auto _ : state) {
    (void)_;
    cl_kernel kernel = clCreateKernel(cd.program, name.c_str(), nullptr);

    ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseKernel(kernel));
  }
}
BENCHMARK(KernelCreateFirstKernelInSource)->Arg(1)->Arg(256)->Arg(16384);

static void KernelCreateLastKernelInSource(benchmark::State &state) {
  std::string source;

  for (unsigned i = 0; i < state.range(0); i++) {
    source += "kernel void func" + std::to_string(i) + "() {}\n";
  }

  const CreateData cd = create_data_from_source(source);

  const std::string name = "func" + std::to_string(state.range(0) - 1);

  for (auto _ : state) {
    (void)_;
    cl_kernel kernel = clCreateKernel(cd.program, name.c_str(), nullptr);

    ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseKernel(kernel));
  }
}
BENCHMARK(KernelCreateLastKernelInSource)->Arg(1)->Arg(256)->Arg(16384);

static void KernelCreateWithRequiredWorkGroupSize(benchmark::State &state) {
  const std::string source =
      "kernel __attribute__((reqd_work_group_size(1, 1, 1)))"
      " void func() {}\n";
  const CreateData cd = create_data_from_source(source);

  const std::string name = "func";

  for (auto _ : state) {
    (void)_;
    cl_kernel kernel = clCreateKernel(cd.program, name.c_str(), nullptr);

    ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseKernel(kernel));
  }
}
BENCHMARK(KernelCreateWithRequiredWorkGroupSize);

static void KernelEnqueueEmpty(benchmark::State &state) {
  const std::string source = "kernel void empty() {}";
  const CreateData cd = create_data_from_source(source);

  const std::string name = "empty";

  cl_int success = CL_SUCCESS;
  cl_command_queue queue =
      clCreateCommandQueue(cd.context, cd.device, 0, &success);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, success);

  cl_kernel kernel = clCreateKernel(cd.program, name.c_str(), &success);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, success);

  const size_t global_size = 1;
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clEnqueueNDRangeKernel(
                                    queue, kernel, 1, nullptr, &global_size,
                                    nullptr, 0, nullptr, nullptr));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(queue));

  for (auto _ : state) {
    (void)_;
    namespace chrono = std::chrono;
    auto start = chrono::high_resolution_clock::now();

    ASSERT_EQ_ERRCODE(CL_SUCCESS, clEnqueueNDRangeKernel(
                                      queue, kernel, 1, nullptr, &global_size,
                                      nullptr, 0, nullptr, nullptr));
    ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(queue));

    auto end = chrono::high_resolution_clock::now();
    auto elapsed = chrono::duration_cast<chrono::duration<double>>(end - start);

    state.SetIterationTime(elapsed.count());
  }

  ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseKernel(kernel));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(queue));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseCommandQueue(queue));
}
BENCHMARK(KernelEnqueueEmpty)->UseManualTime();

static void KernelTiledEnqueue(benchmark::State &state) {
  const std::string source = R"CL(
    __kernel void vector_addition(__global int *src1, __global int *src2,
                                  __global int *dst) {
      size_t gid = get_global_id(0);
      dst[gid] = src1[gid] + src2[gid];
    }
  )CL";

  constexpr size_t item_count = 1 << 24;
  const size_t tile_count = state.range(0);
  assert(item_count > tile_count);

  auto err = cl_int{CL_SUCCESS};
  const CreateData cd = create_data_from_source(source);

  constexpr size_t bytes = sizeof(cl_int) * item_count;

  auto &ctx = cd.context;

  cl_mem src1_buf = clCreateBuffer(ctx, CL_MEM_READ_ONLY, bytes, nullptr, &err);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, err);

  cl_mem src2_buf = clCreateBuffer(ctx, CL_MEM_READ_ONLY, bytes, nullptr, &err);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, err);

  cl_mem dst_buf = clCreateBuffer(ctx, CL_MEM_WRITE_ONLY, bytes, nullptr, &err);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, err);

  /* Create kernel and set arguments */
  cl_kernel ker = clCreateKernel(cd.program, "vector_addition", &err);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, err);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clSetKernelArg(ker, 0, sizeof(src1_buf),
                                               static_cast<void *>(&src1_buf)));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clSetKernelArg(ker, 1, sizeof(src2_buf),
                                               static_cast<void *>(&src2_buf)));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clSetKernelArg(ker, 2, sizeof(dst_buf),
                                               static_cast<void *>(&dst_buf)));

  /* Create command queue */
  cl_command_queue qu = clCreateCommandQueue(ctx, cd.device, 0, &err);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, err);

  /* Enqueue source buffer writes */
  std::vector<cl_int> src1(item_count);
  std::vector<cl_int> src2(item_count);

  /* set data */
  for (size_t i = 0; i < item_count; ++i) {
    src1[i] = i;
    src2[i] = i + 1;
  }

  ASSERT_EQ_ERRCODE(CL_SUCCESS,
                    clEnqueueWriteBuffer(qu, src1_buf, CL_TRUE, 0, bytes,
                                         src1.data(), 0, nullptr, nullptr));
  ASSERT_EQ_ERRCODE(CL_SUCCESS,
                    clEnqueueWriteBuffer(qu, src2_buf, CL_TRUE, 0, bytes,
                                         src2.data(), 0, nullptr, nullptr));

  /* early call to build kernel */
  const size_t work_size = item_count / tile_count;
  ASSERT_EQ_ERRCODE(CL_SUCCESS,
                    clEnqueueNDRangeKernel(qu, ker, 1, nullptr, &work_size,
                                           nullptr, 0, nullptr, nullptr));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(qu));

  for (auto _ : state) {
    (void)_;
    namespace chrono = std::chrono;
    auto start = chrono::high_resolution_clock::now();

    for (size_t i = 0; i < tile_count; ++i) {
      const size_t offset = i * work_size;
      ASSERT_EQ_ERRCODE(CL_SUCCESS,
                        clEnqueueNDRangeKernel(qu, ker, 1, &offset, &work_size,
                                               nullptr, 0, nullptr, nullptr));
    }

    auto end = chrono::high_resolution_clock::now();
    auto elapsed = chrono::duration_cast<chrono::duration<double>>(end - start);

    state.SetIterationTime(elapsed.count());

    ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(qu));
  }

  std::vector<cl_int> dst(item_count);
  ASSERT_EQ_ERRCODE(CL_SUCCESS,
                    clEnqueueReadBuffer(qu, dst_buf, CL_TRUE, 0, bytes,
                                        dst.data(), 0, nullptr, nullptr));

  /* Check the result */
  for (size_t i = 0; i < item_count; ++i) {
    if (dst[i] != src1[i] + src2[i]) {
      /* wrong result */
      assert(false);
    }
  }

  ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseKernel(ker));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(qu));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseCommandQueue(qu));
}
BENCHMARK(KernelTiledEnqueue)
    ->Args({1 << 0})
    ->Args({1 << 5})
    ->Args({1 << 13})
    ->UseManualTime();
// Nothing special about these values, just more tiles.

static void KernelCreateEmptyKernelFromSource(benchmark::State &state) {
  const std::string source = "kernel void empty() {}";
  const CreateData cd = create_data_from_source(source);

  const std::string name = "empty";

  cl_int success = CL_SUCCESS;
  cl_command_queue queue =
      clCreateCommandQueue(cd.context, cd.device, 0, &success);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, success);

  for (auto _ : state) {
    (void)_;
    cl_kernel kernel = clCreateKernel(cd.program, name.c_str(), &success);
    ASSERT_EQ_ERRCODE(CL_SUCCESS, success);

    const size_t global_size = 1;
    ASSERT_EQ_ERRCODE(CL_SUCCESS, clEnqueueNDRangeKernel(
                                      queue, kernel, 1, nullptr, &global_size,
                                      nullptr, 0, nullptr, nullptr));

    ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseKernel(kernel));
  }

  ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(queue));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseCommandQueue(queue));
}
BENCHMARK(KernelCreateEmptyKernelFromSource);

static void KernelCreateEmptyKernelFromBinary(benchmark::State &state) {
  /* create with xxd, 'kernel void empty() {}' */
  unsigned char empty_bc64[] = {
      0x42, 0x43, 0xc0, 0xde, 0x21, 0x0c, 0x00, 0x00, 0x16, 0x01, 0x00, 0x00,
      0x0b, 0x82, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
      0x07, 0x81, 0x23, 0x91, 0x41, 0xc8, 0x04, 0x49, 0x06, 0x10, 0x32, 0x39,
      0x92, 0x01, 0x84, 0x0c, 0x25, 0x05, 0x08, 0x19, 0x1e, 0x04, 0x8b, 0x62,
      0x80, 0x0c, 0x45, 0x02, 0x42, 0x92, 0x0b, 0x42, 0x64, 0x10, 0x32, 0x14,
      0x38, 0x08, 0x18, 0x49, 0x0a, 0x32, 0x44, 0x24, 0x48, 0x0a, 0x90, 0x21,
      0x23, 0xc4, 0x52, 0x80, 0x0c, 0x19, 0x21, 0x72, 0x24, 0x07, 0xc8, 0xc8,
      0x10, 0x62, 0xa8, 0xa0, 0xa8, 0x40, 0xc6, 0xf0, 0x01, 0x00, 0x00, 0x00,
      0x49, 0x18, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b, 0x84, 0xff, 0xff,
      0xff, 0xff, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x89, 0x20, 0x00, 0x00,
      0x0b, 0x00, 0x00, 0x00, 0x32, 0x22, 0xc8, 0x08, 0x20, 0x64, 0x85, 0x04,
      0x93, 0x21, 0xa4, 0x84, 0x04, 0x93, 0x21, 0xe3, 0x84, 0xa1, 0x90, 0x14,
      0x12, 0x4c, 0x86, 0x8c, 0x0b, 0x84, 0x64, 0x4c, 0x10, 0x14, 0x23, 0x00,
      0x25, 0x00, 0x65, 0x20, 0x60, 0x8e, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,
      0x13, 0xac, 0x79, 0x80, 0x87, 0x74, 0x90, 0x07, 0x3b, 0xa0, 0x83, 0x36,
      0xa8, 0x07, 0x77, 0x58, 0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87, 0x36,
      0xa8, 0x07, 0x77, 0x58, 0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87, 0x0d,
      0xae, 0x51, 0x0e, 0x6d, 0x00, 0x0f, 0x7a, 0x60, 0x07, 0x74, 0xa0, 0x07,
      0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xe9, 0x10, 0x07,
      0x7a, 0x80, 0x07, 0x7a, 0x80, 0x07, 0x6d, 0x90, 0x0e, 0x78, 0xa0, 0x07,
      0x78, 0xa0, 0x07, 0x78, 0xd0, 0x06, 0xe9, 0x10, 0x07, 0x76, 0xa0, 0x07,
      0x71, 0x60, 0x07, 0x7a, 0x10, 0x07, 0x76, 0xd0, 0x06, 0xe9, 0x30, 0x07,
      0x72, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06,
      0xe9, 0x60, 0x07, 0x74, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a, 0x60, 0x07,
      0x74, 0xd0, 0x06, 0xe6, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07,
      0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xe6, 0x60, 0x07, 0x74, 0xa0, 0x07,
      0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x10, 0x07,
      0x76, 0xa0, 0x07, 0x71, 0x60, 0x07, 0x7a, 0x10, 0x07, 0x76, 0xd0, 0x06,
      0xf6, 0x20, 0x07, 0x74, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07,
      0x72, 0xd0, 0x06, 0xf6, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07,
      0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xf6, 0x40, 0x07, 0x78, 0xa0, 0x07,
      0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x60, 0x07,
      0x74, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06,
      0xf6, 0x90, 0x07, 0x76, 0xa0, 0x07, 0x71, 0x20, 0x07, 0x78, 0xa0, 0x07,
      0x71, 0x20, 0x07, 0x78, 0xd0, 0x06, 0xf6, 0x10, 0x07, 0x72, 0x80, 0x07,
      0x7a, 0x10, 0x07, 0x72, 0x80, 0x07, 0x7a, 0x10, 0x07, 0x72, 0x80, 0x07,
      0x6d, 0x60, 0x0f, 0x71, 0x90, 0x07, 0x72, 0xa0, 0x07, 0x72, 0x50, 0x07,
      0x76, 0xa0, 0x07, 0x72, 0x50, 0x07, 0x76, 0xd0, 0x06, 0xf6, 0x20, 0x07,
      0x75, 0x60, 0x07, 0x7a, 0x20, 0x07, 0x75, 0x60, 0x07, 0x7a, 0x20, 0x07,
      0x75, 0x60, 0x07, 0x6d, 0x60, 0x0f, 0x75, 0x10, 0x07, 0x72, 0xa0, 0x07,
      0x75, 0x10, 0x07, 0x72, 0xa0, 0x07, 0x75, 0x10, 0x07, 0x72, 0xd0, 0x06,
      0xf6, 0x10, 0x07, 0x70, 0x20, 0x07, 0x74, 0xa0, 0x07, 0x71, 0x00, 0x07,
      0x72, 0x40, 0x07, 0x7a, 0x10, 0x07, 0x70, 0x20, 0x07, 0x74, 0x30, 0x44,
      0x11, 0x58, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x0b, 0x04, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x32, 0x1e, 0x98, 0x08, 0x19, 0x11, 0x4c, 0x90,
      0x8c, 0x09, 0x26, 0x47, 0xc6, 0x04, 0x43, 0x62, 0x09, 0x14, 0x01, 0x00,
      0x79, 0x18, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x43, 0x18, 0x01, 0x18,
      0x82, 0x61, 0x18, 0x8a, 0xe1, 0x18, 0x92, 0x21, 0xc2, 0x20, 0x2c, 0xa8,
      0xd6, 0xa1, 0x1c, 0xe4, 0xc1, 0x1d, 0xca, 0x81, 0x1d, 0x7e, 0x21, 0x1c,
      0xe4, 0xe1, 0x1c, 0x7e, 0x21, 0x1c, 0xc8, 0x81, 0x1c, 0xe4, 0xe1, 0x17,
      0xe6, 0x01, 0x1e, 0xc2, 0x61, 0x1c, 0xca, 0x61, 0x88, 0x30, 0x10, 0x0b,
      0xac, 0x75, 0x28, 0x07, 0x79, 0x70, 0x87, 0x72, 0x60, 0x87, 0x5f, 0x08,
      0x07, 0x79, 0x38, 0x87, 0x5f, 0x08, 0x87, 0x71, 0x18, 0x87, 0x72, 0x98,
      0x87, 0x79, 0xf8, 0x85, 0x78, 0xa8, 0x87, 0x70, 0x60, 0x87, 0x21, 0xc2,
      0x60, 0x2c, 0x78, 0xd6, 0xa1, 0x1c, 0xe4, 0xc1, 0x1d, 0xca, 0x81, 0x1d,
      0x7e, 0x21, 0x1c, 0xe4, 0xe1, 0x1c, 0x7e, 0x81, 0x1e, 0xf2, 0x01, 0x1e,
      0xca, 0x61, 0x88, 0x30, 0x20, 0x0b, 0xa8, 0x75, 0x28, 0x07, 0x79, 0x70,
      0x87, 0x72, 0x60, 0x87, 0x5f, 0x08, 0x07, 0x79, 0x38, 0x87, 0x5f, 0xa0,
      0x87, 0x7c, 0x80, 0x87, 0x72, 0xf8, 0x85, 0x78, 0xa8, 0x87, 0x70, 0x60,
      0x87, 0x21, 0xc2, 0xa0, 0x2c, 0xa0, 0xd6, 0xa1, 0x1c, 0xe4, 0xc1, 0x1d,
      0xca, 0x81, 0x1d, 0x7e, 0x21, 0x1c, 0xe4, 0xe1, 0x1c, 0x7e, 0x41, 0x1c,
      0xc2, 0x61, 0x1e, 0xca, 0xe1, 0x17, 0xe8, 0x21, 0x1f, 0xe0, 0xa1, 0x1c,
      0x86, 0x10, 0x44, 0x40, 0x08, 0x43, 0x80, 0x11, 0xce, 0x3b, 0xc0, 0x43,
      0x39, 0xb8, 0xc3, 0x38, 0xb0, 0x83, 0x1b, 0xac, 0x43, 0x39, 0xc8, 0x83,
      0x3b, 0x94, 0x03, 0x3b, 0xcc, 0xc3, 0x94, 0x00, 0x18, 0x91, 0xbd, 0x03,
      0x3c, 0x94, 0x83, 0x3b, 0x8c, 0x03, 0x3b, 0xb8, 0x41, 0x39, 0xb8, 0x43,
      0x38, 0x88, 0x03, 0x3b, 0x94, 0x83, 0x1b, 0x98, 0x02, 0x2c, 0xfc, 0xc2,
      0x28, 0xbc, 0x82, 0x2b, 0xd0, 0x82, 0x2c, 0x84, 0xc2, 0x28, 0xd0, 0xc2,
      0x14, 0x60, 0xc4, 0xf4, 0x0e, 0xf0, 0x50, 0x0e, 0xee, 0x30, 0x0e, 0xec,
      0xe0, 0x06, 0xf3, 0x00, 0x0f, 0xe9, 0x20, 0x0f, 0x6e, 0x60, 0x0f, 0xe5,
      0x20, 0x0f, 0xf3, 0x90, 0x0e, 0xef, 0xe0, 0x0e, 0x53, 0x82, 0x65, 0x84,
      0xf4, 0x0e, 0xf0, 0x50, 0x0e, 0xee, 0x30, 0x0e, 0xec, 0xe0, 0x06, 0xef,
      0x30, 0x0e, 0xec, 0xe0, 0x06, 0xf6, 0x50, 0x0e, 0xf2, 0x30, 0x0f, 0xe9,
      0xf0, 0x0e, 0xee, 0x30, 0x25, 0x58, 0x46, 0x58, 0xef, 0x00, 0x0f, 0xe5,
      0xe0, 0x0e, 0xe3, 0xc0, 0x0e, 0x6e, 0x50, 0x0f, 0xf3, 0x50, 0x0e, 0xe4,
      0xe0, 0x06, 0xe5, 0x80, 0x0f, 0xf4, 0x50, 0x0e, 0xee, 0x30, 0x0f, 0xe9,
      0xf0, 0x0e, 0xee, 0x30, 0x0f, 0x53, 0x02, 0x66, 0x84, 0x18, 0xbc, 0x03,
      0x3c, 0x94, 0x83, 0x3b, 0x8c, 0x03, 0x3b, 0xb8, 0x41, 0x3d, 0xcc, 0x43,
      0x39, 0x90, 0x83, 0x1b, 0xbc, 0x03, 0x3c, 0xd0, 0x43, 0x3a, 0xbc, 0x83,
      0x3b, 0x84, 0x03, 0x3b, 0xb8, 0xc1, 0x38, 0xbc, 0x83, 0x3c, 0x94, 0x83,
      0x1b, 0x98, 0x43, 0x39, 0x84, 0x03, 0x3d, 0xd4, 0x83, 0x3c, 0x94, 0xc3,
      0x3c, 0x4c, 0x09, 0x98, 0x11, 0xd7, 0x3b, 0xc0, 0x43, 0x39, 0xb8, 0xc3,
      0x38, 0xb0, 0x83, 0x1b, 0x8c, 0xc3, 0x3b, 0xb4, 0x03, 0x3c, 0xa4, 0x03,
      0x3b, 0x94, 0x83, 0x3c, 0xb8, 0xc1, 0x3b, 0xc0, 0x03, 0x3d, 0xa4, 0xc3,
      0x3b, 0xb8, 0xc3, 0x3c, 0x4c, 0x09, 0x18, 0x00, 0x79, 0x18, 0x00, 0x00,
      0x11, 0x00, 0x00, 0x00, 0x33, 0x08, 0x80, 0x1c, 0xc4, 0xe1, 0x1c, 0x66,
      0x14, 0x01, 0x3d, 0x88, 0x43, 0x38, 0x84, 0xc3, 0x8c, 0x42, 0x80, 0x07,
      0x79, 0x78, 0x07, 0x73, 0x98, 0x71, 0x0c, 0xe6, 0x00, 0x0f, 0xed, 0x10,
      0x0e, 0xf4, 0x80, 0x0e, 0x33, 0x0c, 0x42, 0x1e, 0xc2, 0xc1, 0x1d, 0xce,
      0xa1, 0x1c, 0x66, 0x30, 0x05, 0x3d, 0x88, 0x43, 0x38, 0x84, 0x83, 0x1b,
      0xcc, 0x03, 0x3d, 0xc8, 0x43, 0x3d, 0x8c, 0x03, 0x3d, 0x00, 0x00, 0x00,
      0x71, 0x20, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x50, 0x10, 0xcc,
      0x33, 0x61, 0x00, 0x00, 0x61, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x13, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00};

  unsigned char empty_bc32[] = {
      0x42, 0x43, 0xc0, 0xde, 0x21, 0x0c, 0x00, 0x00, 0x15, 0x01, 0x00, 0x00,
      0x0b, 0x82, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
      0x07, 0x81, 0x23, 0x91, 0x41, 0xc8, 0x04, 0x49, 0x06, 0x10, 0x32, 0x39,
      0x92, 0x01, 0x84, 0x0c, 0x25, 0x05, 0x08, 0x19, 0x1e, 0x04, 0x8b, 0x62,
      0x80, 0x0c, 0x45, 0x02, 0x42, 0x92, 0x0b, 0x42, 0x64, 0x10, 0x32, 0x14,
      0x38, 0x08, 0x18, 0x49, 0x0a, 0x32, 0x44, 0x24, 0x48, 0x0a, 0x90, 0x21,
      0x23, 0xc4, 0x52, 0x80, 0x0c, 0x19, 0x21, 0x72, 0x24, 0x07, 0xc8, 0xc8,
      0x10, 0x62, 0xa8, 0xa0, 0xa8, 0x40, 0xc6, 0xf0, 0x01, 0x00, 0x00, 0x00,
      0x49, 0x18, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b, 0x84, 0xff, 0xff,
      0xff, 0xff, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x89, 0x20, 0x00, 0x00,
      0x0b, 0x00, 0x00, 0x00, 0x32, 0x22, 0xc8, 0x08, 0x20, 0x64, 0x85, 0x04,
      0x93, 0x21, 0xa4, 0x84, 0x04, 0x93, 0x21, 0xe3, 0x84, 0xa1, 0x90, 0x14,
      0x12, 0x4c, 0x86, 0x8c, 0x0b, 0x84, 0x64, 0x4c, 0x10, 0x14, 0x23, 0x00,
      0x25, 0x00, 0x65, 0x20, 0x60, 0x8e, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,
      0x13, 0xa8, 0x79, 0x80, 0x87, 0x74, 0x90, 0x87, 0x36, 0xa8, 0x07, 0x77,
      0x58, 0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87, 0x36, 0xa8, 0x07, 0x77,
      0x58, 0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87, 0x0d, 0xae, 0x51, 0x0e,
      0x6d, 0x00, 0x0f, 0x7a, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07,
      0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xe9, 0x10, 0x07, 0x7a, 0x80, 0x07,
      0x7a, 0x80, 0x07, 0x6d, 0x90, 0x0e, 0x78, 0xa0, 0x07, 0x78, 0xa0, 0x07,
      0x78, 0xd0, 0x06, 0xe9, 0x10, 0x07, 0x76, 0xa0, 0x07, 0x71, 0x60, 0x07,
      0x7a, 0x10, 0x07, 0x76, 0xd0, 0x06, 0xe9, 0x30, 0x07, 0x72, 0xa0, 0x07,
      0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xe9, 0x60, 0x07,
      0x74, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06,
      0xe6, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07,
      0x72, 0xd0, 0x06, 0xe6, 0x60, 0x07, 0x74, 0xa0, 0x07, 0x76, 0x40, 0x07,
      0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x10, 0x07, 0x76, 0xa0, 0x07,
      0x71, 0x60, 0x07, 0x7a, 0x10, 0x07, 0x76, 0xd0, 0x06, 0xf6, 0x20, 0x07,
      0x74, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06,
      0xf6, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07,
      0x72, 0xd0, 0x06, 0xf6, 0x40, 0x07, 0x78, 0xa0, 0x07, 0x76, 0x40, 0x07,
      0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x60, 0x07, 0x74, 0xa0, 0x07,
      0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x90, 0x07,
      0x76, 0xa0, 0x07, 0x71, 0x20, 0x07, 0x78, 0xa0, 0x07, 0x71, 0x20, 0x07,
      0x78, 0xd0, 0x06, 0xf6, 0x10, 0x07, 0x72, 0x80, 0x07, 0x7a, 0x10, 0x07,
      0x72, 0x80, 0x07, 0x7a, 0x10, 0x07, 0x72, 0x80, 0x07, 0x6d, 0x60, 0x0f,
      0x71, 0x90, 0x07, 0x72, 0xa0, 0x07, 0x72, 0x50, 0x07, 0x76, 0xa0, 0x07,
      0x72, 0x50, 0x07, 0x76, 0xd0, 0x06, 0xf6, 0x20, 0x07, 0x75, 0x60, 0x07,
      0x7a, 0x20, 0x07, 0x75, 0x60, 0x07, 0x7a, 0x20, 0x07, 0x75, 0x60, 0x07,
      0x6d, 0x60, 0x0f, 0x75, 0x10, 0x07, 0x72, 0xa0, 0x07, 0x75, 0x10, 0x07,
      0x72, 0xa0, 0x07, 0x75, 0x10, 0x07, 0x72, 0xd0, 0x06, 0xf6, 0x10, 0x07,
      0x70, 0x20, 0x07, 0x74, 0xa0, 0x07, 0x71, 0x00, 0x07, 0x72, 0x40, 0x07,
      0x7a, 0x10, 0x07, 0x70, 0x20, 0x07, 0x74, 0x30, 0x44, 0x11, 0x58, 0x01,
      0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x0b, 0x04, 0x05, 0x00, 0x00, 0x00,
      0x32, 0x1e, 0x98, 0x08, 0x19, 0x11, 0x4c, 0x90, 0x8c, 0x09, 0x26, 0x47,
      0xc6, 0x04, 0x43, 0x62, 0x09, 0x14, 0x01, 0x00, 0x79, 0x18, 0x00, 0x00,
      0x72, 0x00, 0x00, 0x00, 0x43, 0x18, 0x01, 0x18, 0x82, 0x61, 0x18, 0x8a,
      0xe1, 0x18, 0x92, 0x21, 0xc2, 0x20, 0x2c, 0xa8, 0xd6, 0xa1, 0x1c, 0xe4,
      0xc1, 0x1d, 0xca, 0x81, 0x1d, 0x7e, 0x21, 0x1c, 0xe4, 0xe1, 0x1c, 0x7e,
      0x21, 0x1c, 0xc8, 0x81, 0x1c, 0xe4, 0xe1, 0x17, 0xe6, 0x01, 0x1e, 0xc2,
      0x61, 0x1c, 0xca, 0x61, 0x88, 0x30, 0x10, 0x0b, 0xac, 0x75, 0x28, 0x07,
      0x79, 0x70, 0x87, 0x72, 0x60, 0x87, 0x5f, 0x08, 0x07, 0x79, 0x38, 0x87,
      0x5f, 0x08, 0x87, 0x71, 0x18, 0x87, 0x72, 0x98, 0x87, 0x79, 0xf8, 0x85,
      0x78, 0xa8, 0x87, 0x70, 0x60, 0x87, 0x21, 0xc2, 0x60, 0x2c, 0x78, 0xd6,
      0xa1, 0x1c, 0xe4, 0xc1, 0x1d, 0xca, 0x81, 0x1d, 0x7e, 0x21, 0x1c, 0xe4,
      0xe1, 0x1c, 0x7e, 0x81, 0x1e, 0xf2, 0x01, 0x1e, 0xca, 0x61, 0x88, 0x30,
      0x20, 0x0b, 0xa8, 0x75, 0x28, 0x07, 0x79, 0x70, 0x87, 0x72, 0x60, 0x87,
      0x5f, 0x08, 0x07, 0x79, 0x38, 0x87, 0x5f, 0xa0, 0x87, 0x7c, 0x80, 0x87,
      0x72, 0xf8, 0x85, 0x78, 0xa8, 0x87, 0x70, 0x60, 0x87, 0x21, 0xc2, 0xa0,
      0x2c, 0xa0, 0xd6, 0xa1, 0x1c, 0xe4, 0xc1, 0x1d, 0xca, 0x81, 0x1d, 0x7e,
      0x21, 0x1c, 0xe4, 0xe1, 0x1c, 0x7e, 0x41, 0x1c, 0xc2, 0x61, 0x1e, 0xca,
      0xe1, 0x17, 0xe8, 0x21, 0x1f, 0xe0, 0xa1, 0x1c, 0x86, 0x10, 0x44, 0x40,
      0x08, 0x43, 0x80, 0x11, 0xce, 0x3b, 0xc0, 0x43, 0x39, 0xb8, 0xc3, 0x38,
      0xb0, 0x83, 0x1b, 0xac, 0x43, 0x39, 0xc8, 0x83, 0x3b, 0x94, 0x03, 0x3b,
      0xcc, 0xc3, 0x94, 0x00, 0x18, 0x91, 0xbd, 0x03, 0x3c, 0x94, 0x83, 0x3b,
      0x8c, 0x03, 0x3b, 0xb8, 0x41, 0x39, 0xb8, 0x43, 0x38, 0x88, 0x03, 0x3b,
      0x94, 0x83, 0x1b, 0x98, 0x02, 0x2c, 0xfc, 0xc2, 0x28, 0xbc, 0x82, 0x2b,
      0xd0, 0x82, 0x2c, 0x84, 0xc2, 0x28, 0xd0, 0xc2, 0x14, 0x60, 0xc4, 0xf4,
      0x0e, 0xf0, 0x50, 0x0e, 0xee, 0x30, 0x0e, 0xec, 0xe0, 0x06, 0xf3, 0x00,
      0x0f, 0xe9, 0x20, 0x0f, 0x6e, 0x60, 0x0f, 0xe5, 0x20, 0x0f, 0xf3, 0x90,
      0x0e, 0xef, 0xe0, 0x0e, 0x53, 0x82, 0x65, 0x84, 0xf4, 0x0e, 0xf0, 0x50,
      0x0e, 0xee, 0x30, 0x0e, 0xec, 0xe0, 0x06, 0xef, 0x30, 0x0e, 0xec, 0xe0,
      0x06, 0xf6, 0x50, 0x0e, 0xf2, 0x30, 0x0f, 0xe9, 0xf0, 0x0e, 0xee, 0x30,
      0x25, 0x58, 0x46, 0x58, 0xef, 0x00, 0x0f, 0xe5, 0xe0, 0x0e, 0xe3, 0xc0,
      0x0e, 0x6e, 0x50, 0x0f, 0xf3, 0x50, 0x0e, 0xe4, 0xe0, 0x06, 0xe5, 0x80,
      0x0f, 0xf4, 0x50, 0x0e, 0xee, 0x30, 0x0f, 0xe9, 0xf0, 0x0e, 0xee, 0x30,
      0x0f, 0x53, 0x02, 0x66, 0x84, 0x18, 0xbc, 0x03, 0x3c, 0x94, 0x83, 0x3b,
      0x8c, 0x03, 0x3b, 0xb8, 0x41, 0x3d, 0xcc, 0x43, 0x39, 0x90, 0x83, 0x1b,
      0xbc, 0x03, 0x3c, 0xd0, 0x43, 0x3a, 0xbc, 0x83, 0x3b, 0x84, 0x03, 0x3b,
      0xb8, 0xc1, 0x38, 0xbc, 0x83, 0x3c, 0x94, 0x83, 0x1b, 0x98, 0x43, 0x39,
      0x84, 0x03, 0x3d, 0xd4, 0x83, 0x3c, 0x94, 0xc3, 0x3c, 0x4c, 0x09, 0x98,
      0x11, 0xd7, 0x3b, 0xc0, 0x43, 0x39, 0xb8, 0xc3, 0x38, 0xb0, 0x83, 0x1b,
      0x8c, 0xc3, 0x3b, 0xb4, 0x03, 0x3c, 0xa4, 0x03, 0x3b, 0x94, 0x83, 0x3c,
      0xb8, 0xc1, 0x3b, 0xc0, 0x03, 0x3d, 0xa4, 0xc3, 0x3b, 0xb8, 0xc3, 0x3c,
      0x4c, 0x09, 0x18, 0x00, 0x79, 0x18, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
      0x33, 0x08, 0x80, 0x1c, 0xc4, 0xe1, 0x1c, 0x66, 0x14, 0x01, 0x3d, 0x88,
      0x43, 0x38, 0x84, 0xc3, 0x8c, 0x42, 0x80, 0x07, 0x79, 0x78, 0x07, 0x73,
      0x98, 0x71, 0x0c, 0xe6, 0x00, 0x0f, 0xed, 0x10, 0x0e, 0xf4, 0x80, 0x0e,
      0x33, 0x0c, 0x42, 0x1e, 0xc2, 0xc1, 0x1d, 0xce, 0xa1, 0x1c, 0x66, 0x30,
      0x05, 0x3d, 0x88, 0x43, 0x38, 0x84, 0x83, 0x1b, 0xcc, 0x03, 0x3d, 0xc8,
      0x43, 0x3d, 0x8c, 0x03, 0x3d, 0x00, 0x00, 0x00, 0x71, 0x20, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x06, 0x50, 0x10, 0xcc, 0x33, 0x61, 0x00, 0x00,
      0x61, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x04, 0x01, 0x02,
      0x00, 0x00, 0x00, 0x00};

  const std::string bin32{std::begin(empty_bc32), std::end(empty_bc32)};
  const std::string bin64{std::begin(empty_bc64), std::end(empty_bc64)};

  const CreateData cd = create_data_from_binary(bin32, bin64);

  const std::string name = "empty";

  cl_int success = CL_SUCCESS;
  cl_command_queue queue =
      clCreateCommandQueue(cd.context, cd.device, 0, &success);
  ASSERT_EQ_ERRCODE(CL_SUCCESS, success);

  for (auto _ : state) {
    (void)_;
    cl_kernel kernel = clCreateKernel(cd.program, name.c_str(), &success);
    ASSERT_EQ_ERRCODE(CL_SUCCESS, success);

    const size_t global_size = 1;
    ASSERT_EQ_ERRCODE(CL_SUCCESS, clEnqueueNDRangeKernel(
                                      queue, kernel, 1, nullptr, &global_size,
                                      nullptr, 0, nullptr, nullptr));

    ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseKernel(kernel));
  }

  ASSERT_EQ_ERRCODE(CL_SUCCESS, clFinish(queue));
  ASSERT_EQ_ERRCODE(CL_SUCCESS, clReleaseCommandQueue(queue));
}
BENCHMARK(KernelCreateEmptyKernelFromBinary);
