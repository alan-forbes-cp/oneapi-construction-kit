name: build run remote_hal
description: build run remote_hal

runs:
  # We don't want a new docker just a list of steps, so mark as composite
  using: "composite"
  steps:
    - name : build server
      shell: bash
      run: |
        mkdir build_server
        cmake -GNinja $GITHUB_WORKSPACE/examples/hal_cpu_remote_server -Bbuild_server -DCMAKE_TOOLCHAIN_FILE=$GITHUB_WORKSPACE/platform/riscv64-linux/riscv64-gcc-toolchain.cmake
        ninja -Cbuild_server
    - name : build client
      shell: bash
      run: |
        cmake -Bbuild_client -GNinja -DCA_MUX_TARGETS_TO_ENABLE="riscv" -DCA_RISCV_ENABLED=ON -DCA_LLVM_INSTALL_DIR=$GITHUB_WORKSPACE/llvm_install -DCA_CL_ENABLE_ICD_LOADER=ON -DCA_HAL_NAME=cpu_client
        ninja -Cbuild_client UnitCL
    - name : run remote_hal
      shell: bash
      run: |
        cd build_server
        export HAL_REMOTE_PORT=9999
        # Limit number of threads to 1 due to hal cpu use of temporary threads causing excessive qemu memory usage.
        export CA_CPU_HAL_NUM_THREADS=1
        /usr/bin/qemu-riscv64 -L /usr/riscv64-linux-gnu ./hal_cpu_server_bin $HAL_REMOTE_PORT &
        # This gives enough time for the server to start. We should consider whether a better
        # design could avoid this - see OR-380
        ( /usr/bin/qemu-riscv64 -L /usr/riscv64-linux-gnu ./hal_cpu_server_bin $HAL_REMOTE_PORT > /tmp/hal 2>&1 ) &
        tries=10
        while [ "$tries" -gt 0 ] && ! grep "Listening on port $HAL_REMOTE_PORT" /tmp/hal ; do
          sleep 1
          tries=$(( tries - 1 ))
        done
        rm /tmp/hal
        if [ "$tries" -ne 0 ]; then
          jobs
          cd $GITHUB_WORKSPACE/build_client
          exitcode=0
          OCL_ICD_FILENAMES=$PWD/lib/libCL.so.4.0 ./bin/UnitCL || exitcode=$?
          kill %1
          exit $exitcode
        else
          echo "Server has failed to start"
          exit 1
        fi
