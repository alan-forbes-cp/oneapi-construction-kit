From 6fa99e8df559642c80c234fdc584b9d6a442a978 Mon Sep 17 00:00:00 2001
From: PietroGhg <pietro.ghiglio@codeplay.com>
Date: Wed, 19 Jun 2024 13:21:16 +0100
Subject: [PATCH] Handle Native CPU flow in clang-linker-wrapper

---
 .../ClangLinkerWrapper.cpp                    | 115 ++++++++++++++++--
 .../Offloading/SYCLOffloadWrapper.cpp         |   9 +-
 sycl/test/native_cpu/atomic-base.cpp          |   3 +
 sycl/test/native_cpu/multiple_tu.cpp          |   7 ++
 sycl/test/native_cpu/vector-add.cpp           |   4 +
 5 files changed, 120 insertions(+), 18 deletions(-)

diff --git a/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp b/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
index 8ea4f3ef8755..8c3dd1c838c1 100644
--- a/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
+++ b/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
@@ -18,6 +18,7 @@
 #include "clang/Basic/TargetID.h"
 #include "clang/Basic/Version.h"
 #include "llvm/ADT/MapVector.h"
+#include "llvm/ADT/SmallString.h"
 #include "llvm/BinaryFormat/Magic.h"
 #include "llvm/Bitcode/BitcodeWriter.h"
 #include "llvm/CodeGen/CommandFlags.h"
@@ -673,9 +674,8 @@ getTripleBasedSYCLPostLinkOpts(const ArgList &Args,
   // because it only increases amount of code for device compiler to handle,
   // without any actual benefits.
   // TODO: Try to extend this feature for non-Intel GPUs.
-  if ((!Args.hasFlag(OPT_no_sycl_remove_unused_external_funcs,
-                     OPT_sycl_remove_unused_external_funcs, false) &&
-       !SYCLNativeCPU) &&
+  if (!Args.hasFlag(OPT_no_sycl_remove_unused_external_funcs,
+                    OPT_sycl_remove_unused_external_funcs, false) &&
       !Args.hasArg(OPT_sycl_allow_device_image_dependencies) &&
       !Triple.isNVPTX() && !Triple.isAMDGPU())
     PostLinkArgs.push_back("-emit-only-kernels-as-entry-points");
@@ -1106,6 +1106,15 @@ wrapSYCLBinariesFromFile(std::vector<module_split::SplitModule> &SplitModules,
                         ImageTarget);
   }
 
+  // Set image target string to native_cpu for Native CPU target.
+  // TODO: does this work when multiple sycl targets are enabled?
+  const llvm::Triple HostTriple(Args.getLastArgValue(OPT_host_triple_EQ));
+  bool SYCLNativeCPU = (HostTriple == T);
+  if (SYCLNativeCPU) {
+    for (offloading::SYCLImage &Image : Images)
+      Image.Target = "native_cpu";
+  }
+
   LLVMContext C;
   Module M("offload.wrapper.object", C);
   M.setTargetTriple(
@@ -1243,8 +1252,8 @@ Expected<StringRef> linkDeviceInputFiles(SmallVectorImpl<StringRef> &InputFiles,
 /// code and will be parsed to generate options required to be passed into the
 /// llvm-link tool.
 static Expected<StringRef>
-linkDeviceLibFiles(SmallVectorImpl<StringRef> &InputFiles,
-                   const ArgList &Args) {
+linkDeviceLibFiles(SmallVectorImpl<StringRef> &InputFiles, const ArgList &Args,
+                   bool OnlyNeeded = true) {
   llvm::TimeTraceScope TimeScope("LinkDeviceLibraryFiles");
 
   Expected<std::string> LLVMLinkPath =
@@ -1260,7 +1269,8 @@ linkDeviceLibFiles(SmallVectorImpl<StringRef> &InputFiles,
 
   SmallVector<StringRef, 8> CmdArgs;
   CmdArgs.push_back(*LLVMLinkPath);
-  CmdArgs.push_back("-only-needed");
+  if (OnlyNeeded)
+    CmdArgs.push_back("-only-needed");
   for (auto &File : InputFiles)
     CmdArgs.push_back(File);
   CmdArgs.push_back("-o");
@@ -1297,6 +1307,7 @@ static Expected<StringRef> linkDevice(ArrayRef<StringRef> InputFiles,
     reportError(std::move(Err));
   const llvm::Triple Triple(Args.getLastArgValue(OPT_triple_EQ));
   SmallVector<std::string, 16> ExtractedDeviceLibFiles;
+  std::string NativeCPUUtilsLib = "";
   for (auto &File : DeviceLibFiles) {
     auto BufferOrErr = MemoryBuffer::getFile(File);
     if (!BufferOrErr)
@@ -1341,6 +1352,42 @@ static Expected<StringRef> linkDevice(ArrayRef<StringRef> InputFiles,
     }
   }
 
+  // Native CPU needs libclc as device library
+  const llvm::Triple HostTriple(Args.getLastArgValue(OPT_host_triple_EQ));
+  const bool IsSYCLNativeCPU = Triple == HostTriple;
+  if (IsSYCLNativeCPU) {
+    if (auto *A = Args.getLastArg(OPT_sycl_device_library_location_EQ)) {
+      SmallVector<std::string, 8> LibraryPaths;
+      for (const auto &Path : A->getValues()) {
+        SmallString<128> LPath(Path);
+        if (llvm::sys::fs::exists(LPath)) {
+          LibraryPaths.emplace_back(LPath);
+        }
+      }
+
+      for (auto &LPath : LibraryPaths) {
+        std::string LibSpirvTargetName =
+            (HostTriple.isOSWindows()) ? "remangled-l32-signed_char.libspirv-"
+                                       : "remangled-l64-signed_char.libspirv-";
+        LibSpirvTargetName.append(Triple.str() + ".bc");
+        SmallString<128> LibSpirvPath(LPath);
+        llvm::sys::path::append(LibSpirvPath, Twine("clc"));
+        llvm::sys::path::append(LibSpirvPath, LibSpirvTargetName);
+        if (llvm::sys::fs::exists(LibSpirvPath))
+          ExtractedDeviceLibFiles.emplace_back(LibSpirvPath);
+
+        // Call llvm-link without --only-needed to link to the nativecpu_utils
+        // lib
+        const char LibNativeCPUUtilsName[] = "libsycl-nativecpu_utils.bc";
+        SmallString<128> LibNativeCPUUtilsPath(LPath);
+        llvm::sys::path::append(LibNativeCPUUtilsPath, LibNativeCPUUtilsName);
+        if (llvm::sys::fs::exists(LibNativeCPUUtilsPath)) {
+          NativeCPUUtilsLib = LibNativeCPUUtilsPath.str();
+        }
+      }
+    }
+  }
+
   // Make sure that SYCL device library files are available.
   // Note: For AMD targets, we do not pass any SYCL device libraries.
   if (ExtractedDeviceLibFiles.empty()) {
@@ -1354,11 +1401,20 @@ static Expected<StringRef> linkDevice(ArrayRef<StringRef> InputFiles,
 
   for (auto &File : ExtractedDeviceLibFiles)
     InputFilesVec.emplace_back(File);
+
   // second llvm-link step
   auto DeviceLinkedFile = sycl::linkDeviceLibFiles(InputFilesVec, Args);
   if (!DeviceLinkedFile)
     reportError(DeviceLinkedFile.takeError());
 
+  // link NativeCPU utils lib if needed
+  if (NativeCPUUtilsLib != "") {
+    SmallVector<StringRef, 2> InFiles{*DeviceLinkedFile, NativeCPUUtilsLib};
+    DeviceLinkedFile = sycl::linkDeviceLibFiles(InFiles, Args, false);
+    if (!DeviceLinkedFile)
+      reportError(DeviceLinkedFile.takeError());
+  }
+
   return *DeviceLinkedFile;
 }
 
@@ -1499,7 +1555,7 @@ Error extractBundledObjects(StringRef Filename, const ArgList &Args,
 
 namespace generic {
 Expected<StringRef> clang(ArrayRef<StringRef> InputFiles, const ArgList &Args,
-                          bool IsSYCLKind = false) {
+                          bool IsSYCLKind = false, bool IsNativeCPU = false) {
   llvm::TimeTraceScope TimeScope("Clang");
   // Use `clang` to invoke the appropriate device tools.
   Expected<std::string> ClangPath =
@@ -1526,7 +1582,7 @@ Expected<StringRef> clang(ArrayRef<StringRef> InputFiles, const ArgList &Args,
       "--no-default-config",
       "-o",
       *TempFileOrErr,
-      Args.MakeArgString("--target=" + Triple.getTriple()),
+      !IsNativeCPU ? Args.MakeArgString("--target=" + Triple.getTriple()) : "",
       Triple.isAMDGPU() ? Args.MakeArgString("-mcpu=" + Arch)
                         : Args.MakeArgString("-march=" + Arch),
       Args.MakeArgString("-" + OptLevel),
@@ -1540,7 +1596,7 @@ Expected<StringRef> clang(ArrayRef<StringRef> InputFiles, const ArgList &Args,
 
   if (Triple.isNVPTX() || Triple.isAMDGPU()) {
     CmdArgs.push_back("-foffload-lto");
-  } else {
+  } else if (!IsNativeCPU) {
     CmdArgs.push_back("-flto");
   }
 
@@ -1549,11 +1605,19 @@ Expected<StringRef> clang(ArrayRef<StringRef> InputFiles, const ArgList &Args,
 
   if (IsSYCLKind && Triple.isNVPTX())
     CmdArgs.push_back("-S");
+
+  if (IsSYCLKind && IsNativeCPU) {
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-sycl-native-cpu-backend");
+    CmdArgs.push_back("-c");
+  }
+
   for (StringRef InputFile : InputFiles)
     CmdArgs.push_back(InputFile);
 
   // If this is CPU offloading we copy the input libraries.
-  if (!Triple.isAMDGPU() && !Triple.isNVPTX() && !Triple.isSPIRV()) {
+  if (!Triple.isAMDGPU() && !Triple.isNVPTX() && !Triple.isSPIRV() &&
+      !IsNativeCPU) {
     CmdArgs.push_back("-Wl,-Bsymbolic");
     CmdArgs.push_back("-shared");
     ArgStringList LinkerArgs;
@@ -1638,6 +1702,11 @@ Expected<StringRef> clang(ArrayRef<StringRef> InputFiles, const ArgList &Args,
 Expected<StringRef> linkDevice(ArrayRef<StringRef> InputFiles,
                                const ArgList &Args, bool IsSYCLKind = false) {
   const llvm::Triple Triple(Args.getLastArgValue(OPT_triple_EQ));
+  const llvm::Triple HostTriple(Args.getLastArgValue(OPT_host_triple_EQ));
+  bool SYCLNativeCPU = (HostTriple == Triple);
+  if (IsSYCLKind && SYCLNativeCPU) {
+    return StringRef("");
+  }
   switch (Triple.getArch()) {
   case Triple::nvptx:
   case Triple::nvptx64:
@@ -1831,6 +1900,10 @@ Error linkBitcodeFiles(SmallVectorImpl<OffloadFile> &InputFiles,
   StringRef Arch = Args.getLastArgValue(OPT_arch_EQ);
 
   // Early exit for SPIR targets
+  const llvm::Triple HostTriple(Args.getLastArgValue(OPT_host_triple_EQ));
+  bool SYCLNativeCPU = (HostTriple == Triple);
+  if (SYCLNativeCPU)
+    return Error::success();
   if (Triple.isSPIROrSPIRV())
     return Error::success();
 
@@ -2398,6 +2471,8 @@ Expected<SmallVector<StringRef>> linkAndWrapDeviceFiles(
 
       auto &SplitModules = *SplitModulesOrErr;
       const llvm::Triple Triple(LinkerArgs.getLastArgValue(OPT_triple_EQ));
+      const llvm::Triple HostTriple(Args.getLastArgValue(OPT_host_triple_EQ));
+      bool SYCLNativeCPU = (HostTriple == Triple);
       if ((Triple.isNVPTX() || Triple.isAMDGCN()) &&
           LinkerArgs.hasArg(OPT_sycl_embed_ir)) {
         // When compiling for Nvidia/AMD devices and the user requested the
@@ -2442,6 +2517,8 @@ Expected<SmallVector<StringRef>> linkAndWrapDeviceFiles(
           if (!BundledFileOrErr)
             return BundledFileOrErr.takeError();
           SplitModules[I].ModuleFilePath = *BundledFileOrErr;
+        } else if (SYCLNativeCPU) {
+          // TODO: not really sure if we need to do anything here
         } else {
           SplitModules[I].ModuleFilePath = *ClangOutputOrErr;
         }
@@ -2452,6 +2529,24 @@ Expected<SmallVector<StringRef>> linkAndWrapDeviceFiles(
       if (!OutputFile)
         return OutputFile.takeError();
 
+      // Generates the clang call that compiles the device module for Native
+      // CPU. The output of the call is added to the linker inputs.
+      // TODO: ideally we would like to run this clang invocation over each of
+      // modules that result from device code splitting, is it possible to do
+      // so with the new offload approach?
+      if (SYCLNativeCPU) {
+        // TODO: we set IsNativeCPU to true here since we need to add the
+        // -mllvm -sycl-native-cpu-backend option, which triggers the SYCL
+        // Native CPU pass pipeline. Perhaps we could move the SYCL Native CPU
+        // pass pipeline to sycl-post-link, and run an umodified clang
+        // invocation on the modules that come out of sycl-post-link.
+        auto NCpuObj = generic::clang(
+            {*TmpOutputOrErr}, Args, /*IsSYCLKind*/ true, /*IsNativeCPU*/ true);
+        if (!NCpuObj)
+          return NCpuObj.takeError();
+        std::scoped_lock Guard(ImageMtx);
+        WrappedOutput.push_back(*NCpuObj);
+      }
       // SYCL offload kind images are all ready to be sent to host linker.
       // TODO: Currently, device code wrapping for SYCL offload happens in a
       // separate path inside 'linkDevice' call seen above.
diff --git a/llvm/lib/Frontend/Offloading/SYCLOffloadWrapper.cpp b/llvm/lib/Frontend/Offloading/SYCLOffloadWrapper.cpp
index 5cd54df70e3e..19848ddcb574 100644
--- a/llvm/lib/Frontend/Offloading/SYCLOffloadWrapper.cpp
+++ b/llvm/lib/Frontend/Offloading/SYCLOffloadWrapper.cpp
@@ -221,15 +221,8 @@ struct Wrapper {
     FunctionType *NativeCPUFuncTy = FunctionType::get(
         Type::getVoidTy(C),
         {PointerType::getUnqual(C), PointerType::getUnqual(C)}, false);
-    FunctionType *NativeCPUBuiltinTy = FunctionType::get(
-        PointerType::getUnqual(C), {PointerType::getUnqual(C)}, false);
-    FunctionType *FTy;
-    if (Name.starts_with("__dpcpp_nativecpu"))
-      FTy = NativeCPUBuiltinTy;
-    else
-      FTy = NativeCPUFuncTy;
     auto FCalle = M.getOrInsertFunction(
-        sycl::utils::addSYCLNativeCPUSuffix(Name).str(), FTy);
+        sycl::utils::addSYCLNativeCPUSuffix(Name).str(), NativeCPUFuncTy);
     Function *F = dyn_cast<Function>(FCalle.getCallee());
     if (F == nullptr)
       report_fatal_error("Unexpected callee");
diff --git a/sycl/test/native_cpu/atomic-base.cpp b/sycl/test/native_cpu/atomic-base.cpp
index ee84a90c8a89..15deb2e27564 100644
--- a/sycl/test/native_cpu/atomic-base.cpp
+++ b/sycl/test/native_cpu/atomic-base.cpp
@@ -4,6 +4,9 @@
 // RUN: %clangxx -fsycl -fsycl-targets=native_cpu %s -o %t
 // RUN: env ONEAPI_DEVICE_SELECTOR="native_cpu:cpu" %t
 
+// RUN: %clangxx -fsycl -fsycl-targets=native_cpu %s -o %t-new --offload-new-driver
+// RUN: env ONEAPI_DEVICE_SELECTOR="native_cpu:cpu" %t-new
+
 #include <sycl/sycl.hpp>
 #include <vector>
 
diff --git a/sycl/test/native_cpu/multiple_tu.cpp b/sycl/test/native_cpu/multiple_tu.cpp
index b4d5338dc0f4..2162f4605c38 100644
--- a/sycl/test/native_cpu/multiple_tu.cpp
+++ b/sycl/test/native_cpu/multiple_tu.cpp
@@ -12,6 +12,13 @@
 //RUN: %clangxx -fsycl -fsycl-targets=native_cpu -g %t_plusone-debug.o %t_main-debug.o %t_init-debug.o -o %t-debug
 //RUN: env ONEAPI_DEVICE_SELECTOR=native_cpu:cpu %t-debug
 
+// New offload driver
+//RUN: %clangxx -fsycl -fsycl-targets=native_cpu --offload-new-driver %s -c -o %t_main-new_offload.o
+//RUN: %clangxx -fsycl -fsycl-targets=native_cpu --offload-new-driver %S/Inputs/init.cpp -c -o %t_init-new_offload.o
+//RUN: %clangxx -fsycl -fsycl-targets=native_cpu --offload-new-driver %S/Inputs/plusone.cpp -c -o %t_plusone-new_offload.o
+//RUN: %clangxx -fsycl -fsycl-targets=native_cpu --offload-new-driver %t_plusone-new_offload.o %t_main-new_offload.o %t_init-new_offload.o -o %t-new_offload
+//RUN: env ONEAPI_DEVICE_SELECTOR=native_cpu:cpu %t-new_offload
+
 #include "Inputs/common.h"
 #include <iostream>
 
diff --git a/sycl/test/native_cpu/vector-add.cpp b/sycl/test/native_cpu/vector-add.cpp
index e9aecbd00af8..30b03725c69f 100644
--- a/sycl/test/native_cpu/vector-add.cpp
+++ b/sycl/test/native_cpu/vector-add.cpp
@@ -22,6 +22,10 @@
 // verify the (profiling) outputs.
 // RUN: %clangxx -fsycl -fsycl-targets=native_cpu %s -fprofile-instr-generate -fcoverage-mapping -mllvm -system-headers-coverage -c -o %t
 
+// Use new offload driver
+// RUN: %clangxx -fsycl -fsycl-targets=native_cpu %s -o %t-new --offload-new-driver
+// RUN: env ONEAPI_DEVICE_SELECTOR="native_cpu:cpu" %t-new
+
 #include <sycl/sycl.hpp>
 
 #include <array>
-- 
2.39.5 (Apple Git-154)

